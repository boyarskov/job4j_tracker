package ru.job4j.stream;

import ru.job4j.stream.Pupil;
import ru.job4j.stream.Tuple;

import java.util.List;
import java.util.stream.Stream;

public class Analyze {
    //Класс Analyze получает статистику по аттестатам.
    public static double averageScore(Stream<Pupil> stream) {
        //Метод averageScore() - вычисляет общий средний балл.
//        для реализации понадобятся методы:
//        - flatMap() для преобразования в поток объектов Subject;

//        - mapToInt() для последующего преобразования в потом оценок по каждому предмету;

//        - average() для расчета среднего бала по предмету;

//        - orElse() для того чтобы вернуть значение по умолчанию.
        return 0D;
    }

    public static List<Tuple> averageScoreByPupil(Stream<Pupil> stream) {
        //Метод averageScoreByPupil() - вычисляет средний балл по каждому ученику.
        //нам надо выполнить преобразование в поток объектов класса Tuple, последовательность будет следующей:

        //- метод map() для преобразования в поток объектов класса Tuple, внутри метода мы будем создавать эти объекты
        // - там будет фигурировать строка new Tuple();

        //- при этом в конструктор первым параметром будет передаваться имя текущего объекта Pupil - используем соответствующий геттер;

        //- вторым параметром рассчитанный средний балл - расчет можно произвести по той же последовательности,
        // что описана для метода averageScore;

        //- последним методом будет collect(), с помощью которого мы все соберем в коллекцию List.
        return List.of();
    }

    public static List<Tuple> averageScoreBySubject(Stream<Pupil> stream) {
        //Метод averageScoreBySubject() - вычисляет средний балл по каждому предмету.
        //Pеализация этого метода несколько сложна, поскольку в данном случае требуется выполнить промежуточный сбор данных в Map().
        // Опишем вкратце алгоритм:

        //- flatMap() для преобразования в поток объектов Subject;

        //- метод collect() в который мы передаем метод groupingBy() (с тремя параметрами) класса Collectors. При этом карта собирается следующим образом: ключ (первый параметр) - это имя предмета, второй параметр - тип карты, который будем использовать (в нашем случае нужен LinkedHashMap::new, который позволит хранить пары ключ-значение в порядке поступления), значение карты (третий параметр) - средний балл по этому предмету для каждого ученика. Для расчета среднего балла используйте метод averagingDouble() класса Collectors;

        //- после этого собранную карту мы разбираем с помощью entrySet() и открываем поток с помощью stream();

        //- полученный поток с помощью map() преобразуем в поток объектов класса Tuple, внутри метода мы будем создавать эти объекты - там будет фигурировать строка new Tuple();

        //- в конструктор мы будем передавать параметры с помощью методов getKey() и getValue() интерфейса Entry;

        //- последним методом будет collect(), с помощью которого мы все соберем в коллекцию List.
        return List.of();
    }

    public static Tuple bestStudent(Stream<Pupil> stream) {
        //Метод bestStudent() - возвращает лучшего ученика. Лучшим считается ученик с наибольшим суммарным баллом по всем предметам.
        //для реализации данного метода можно использовать метод averageScoreBySubject за исключением следующих особенностей:
        //- в данном методе мы рассчитываем суммарный балл, а не средний - поэтому вместо average() нужно использовать метод sum();

        //- терминальной операцией будет не метод collect(), а использование метода max(), в который будем передавать компаратор. При этом компаратор определит объект Tuple, у которого значение Score будет максимальным;

        //- orElse() для того чтобы вернуть значение по умолчанию.
        return null;
    }

    public static Tuple bestSubject(Stream<Pupil> stream) {
        //Метод bestSubject() - возвращает предмет с наибольшим баллом для всех студентов.
        //для реализации данного метода можно использовать метод averageScoreByPupil за исключением следующих особенностей:
        //- в данном методе мы рассчитываем суммарный балл, а не средний - поэтому вместо averagingDouble() нужно использовать метод summingDouble();

        //- терминальной операцией будет не метод collect(), а использование метода max(), в который будем передавать компаратор. При этом компаратор определит объект Tuple, у которого значение Score будет максимальным;

        //- orElse() для того чтобы вернуть значение по умолчанию.
        return null;
    }
}
