# Экзамен. ООП 
## Контрольные вопросы - ООП

###1. Что такое ООП?
Java является объектно-ориентированным языком. Это означает, что писать программы на Java нужно с применением объектно-ориентированного стиля / методологии. И стиль этот основан на использовании в программе объектов и классов. Из каждого класса можно создать объект у которого будет набор свойств и методов.
###2. Базовые концепции ООП?
* Абстракция
* Инкапсуляция
* Наследование
* Полиморфизм
  
Аналогия. Чертеж дома = Класс. Абстрактная вещь, шаблон. <br>
Дом = объект (экземпляр класса), создан по правилам чертежа.<br>
Объект имеет все атрибуты, что есть в классе (перечень атрибутов, действий)
   
Class имя_класса {<br>
Тип переменная экземпляра;<br>
Тип имя методов(список параментров) {<br>
// тело метода<br>
}<br>
Простой класс:<br>
Class Box {<br>
Double width;<br>
Double height;<br>
}<br>
   
Box mybox = new Box(); - создать объект mybox класса Box<br>
Для доступа к этим переменным нужна операция:<br>
Mybox.width = 100;
###3. Укажите из каких элементов состоит класс.
   Класс состоит из полей (атрибуты) и методов (функции для работы с этими полями). Поле (атрибут) класса — это характеристика объекта, содержит его состояние. Например для фигуры это может быть название, площадь, периметр.<br>
   Класс является ссылочным типом данных.<br>
   Класс определяет форму и сущность объекта. Класс определяет новый тип данных. Любой класс в java – это тип данных. Как только он определен, им можно воспользоваться для создания объекта.<br>
   Класс используется для а) дробления кода (class home: class floor, class wall, class roof), б) повторное использование, создав один раз класс, можно его использовать несколько раз.<br>
###4. Что такое конструктор?
   Конструктор — это специальный метод, который вызывается при создании нового объекта (всегда вызывается совместно с операцией new). Он конструирует объект.<br>
   Конструктор нужен для автоматической инициализации переменных, т.е. он инициализирует объект непосредственно во время создания. Имя конструктора совпадает с именем класса, включая регистр, а по синтаксису конструктор похож на метод без возвращаемого значения void.<br>
   Нужен чтобы человек вписывал поля переменных.<br>
   Существуют:<br>
* конструктор по умолчанию или неявный (без параметров - позволяет регулировать, какие параметры и в каком количестве нужно задать для создания объекта определенного класса).
* конструктор с параметрами или явный.<br>
  
  public Car(String model, int maxSpeed) {<br>
  this.model = model;<br>
  this.maxSpeed = maxSpeed;<br>
  }<br>
###5. Можно ли наследовать конструктор?
   Нет, но ему можно передать аргументы с помощью super.<br>
   В Java подкласс наследует все члены (поля, методы, вложенные классы) из суперкласса. Конструкторы не являются членами, поэтому они не наследуются, но конструктор суперкласса м.б. вызван из подкласса.<br>
   Конструктор похож на метод, но не является методом, он даже не считается членом класса. Поэтому его нельзя наследовать или переопределить в подклассе.<br>
   Конструкторы не наследуются подклассами, но конструктор подкласса должен вызывать конструктор в суперклассе.<br>
   Если базовый класс не содержит конструктора с аргументами, тогда в классах наследниках не обязательно писать super(),эти вызовы расставит компилятор.<br>
   Если же у базового класса есть конструктор с аргументами, тогда уже Вам необходимо указать эти аргументы, соответственно необходимо и конструктор базового класса вызвать.<br>
   Можно так же передать управление какому-то конструктору из текущего класса, вызвав this(), но эта цепочка должна привести к вызову конструктора базового класса<br>
###6. Что такое перегрузка конструктора?
   Перегрузка конструктора - это создание конструкторов с другим набором аргументов (как по количеству, так и по порядку следования).<br>
   Если был создан конструктор, принимающий аргументы, а нам нужен конструктор по умолчанию (без аргументов), то его нужно создать явно.
###7. Что такое статический метод?
   Статический метод - это метод, который можно вызвать без создания объекта, напрямую через имя класса. Модификатора static  - делает переменную или метод "независимыми" от объекта.<br>
   Статические методы нельзя переопределять.<br>
   Статические методы могут ссылаться только на статические переменные. Это гарантирует, что во время выполнения нашего метода все элементы будут инициализированы и будут работать. Это называется "статическим контекстом".<br>
###8. Что такое не статический метод?
   Если нам понадобится не статический метод, понадобится создавать объект класса.<br>
   Т.е. он принадлежит объекту класса и может быть вызван с помощью ссылки на данный объект.<br>
###9. Для чего используется ключевое слово this?
   this - это неявный первый параметр любого нестатического метода класса.<br>
   Для отличия переменной класса от переменной метода. Указывает на конкретную переменную. У какого объекта вызывается метод, тот и будет передан в качестве параметра this.
   соответственно, this используется:<br>
* в теле любого метода для ссылки на текущий объект<br>
* когда нужно вызвать один конструктор из другого<br>
   главное отличие между this и super в Java в том, что this представляет текущий экземпляр класса, в то время как super - текущий экземпляр родительского класса.
###10. Какой класс является базовый родительным классов для всех классов?
Object - корневой класс в иерархии классов Java.<br>
Все непримитивный типы, включая массивы, наследуют прямо или косвенно от него. Поэтому ссылочная переменная класса Object может ссылаться на объект любого другого класса.<br>
Ключевое слово super представляет текущий экземпляр родительского класса.<br>
###11. Что такое наследование? Приведите примеры из реальной жизни.
Это когда один объект перенимает все публичные поля и методы другого объекта.<br>
    Животные > Собаки > Овчарки, Мопсы, Хаски и тд.

Main class: Animal<br>
    Public class Dog extends Animal {<br>
    }<br>

Рассматриваем собаку, как животное:<br>
    Animal animal = new Dog(); можем обращаться через переменную родительского класса.

Рассматриваем собаку, как собаку:<br>
    Dog dog = new Dog();
###12. Опишите процесс создания нового объекта.
Cat peppy = new Cat();<br>
    Мы создаем переменную типа Cat с именем peppy. Далее мы записываем в эту переменную объект типа Cat.<br>
    Важный момент. Оператор new резервирует кусок памяти и записывает в нее данные объекта класса Cat.<br>
    Чем нам программистам интересны объекты? А тем, что они позволяют абстрагироваться или отвлечься от внутреннего устройства объекта и сфокусироваться на свойствах и возможностях этого объекта.<br>
###13. Как вызвать метод из родительского класса?
Если метод родительского класса переопределен, а нужно вызвать оригинальную версию метода, то нужно использовать ключевое слово super, которое представляет текущий экземпляр родительского класса.<br>
    Ключевое слово super имеет две общие формы.<br>
    Первую используют для вызова конструктора суперкласса, а вторую — для обращения к члену суперкласса, скрытому членом подкласса.
###14. Что такое переопределение метода?
Переопределение методов в Java (Override)  — один из инструментов для реализации идеи полиморфизма.<br>
    Переопределение метода (Method overriding) это возможность языка позволяющая подклассу или дочернему элементу классу обеспечивать специфическую реализацию метода, который уже реализовали в одном из супер-классов или родительском классе. Переопределение выглядит так:<br>
    public class App {<br>
    public static void main(String[] args) {<br>
    Dog dog = new Dog();<br>
    Cat cat = new Cat();<br>

dog.voice(); // Вывод: Гав<br>
        cat.voice(); // Вывод: Мяу<br>
    }<br>
    }<br>

class Animal { // родительский класс<br>
public void voice() {<br>
System.out.print("Голос животного");<br>
}<br>
}<br>

class Dog extends Animal { // класс-наследник<br>

@Override // Переопределение метода voice() унаследованного от класса Animal в классе-наследнике Dog<br>
    public void voice() {<br>
        System.out.print("Гав");<br>
    }<br>
}<br>

class Cat extends Animal { // класс-наследник<br>

@Override // Переопределение метода voice() унаследованного от класса Animal в классе-наследнике Cat<br>
    public void voice() {<br>
        System.out.print("Мяу");<br>
    }<br>

}<br>
Переопределенный метод должен иметь тот же модификатор доступа что его родитель, принимать аргументы как его родитель, и иметь возвращаемый тип такой же как у его родителя<br>
Т.е.<br>
public class App {<br>
public static void main(String[] args) {<br>
Dog dog = new Dog();<br>
Cat cat = new Cat();<br>

dog.voice("Шарик", 10); // Вывод: Гав<br>
        cat.voice("не Шарик", 7); // Вывод: Мяу<br>
    }<br>
}<br>

class Animal {<br>
// Родительский метод имеет возвращаемый тип String. Принимает два параметра, типа String и int<br>
public String voice(String animal_name, int animal_age) {<br>
System.out.print("Гав");<br>

return animal_name;<br>
    }<br>
}

class Dog extends Animal{<br>
// Переопределенный метод должен как его родитель, иметь возвращаемый тип String, и принимать параметры как его родитель<br>
@Override<br>
public String voice(String dog_name, int dog_age) {<br>
System.out.print("Гав");<br>

return dog_name;<br>
    }<br>
}<br>

class Cat extends Animal {<br>
@Override<br>
public String voice(String cat_name, int cat_age) {<br>
System.out.print("Мяу");        <br>
return cat_name;<br>
}<br>
}<br>

Главным преимуществом его использования будет гибкость. Переопределение позволяет взять какой-то метод родительского класса и написать в каждом классе-наследнике свою реализацию этого метода. Новая реализация «заменит» родительскую в дочернем классе.<br>
Мы можем выстроить простую и логичную систему классов, каждый из которых будет обладать специфическим поведением (собаки лают, кошки мяукают), но единым интерфейсом — один метод voice() на всех вместо кучи методов voiceDog(), voiceCat() и т.д.<br>
чтобы переопределить методы родительского класса, перейди в код класса-наследника в Intellij IDEa, нажми Ctrl+O и выбери в меню «Override methods...»
У переопределения есть ряд ограничений:<br>
- У переопределенного метода должны быть те же аргументы, что и у метода родителя.<br>
- У переопределенного метода должен быть тот же тип возвращаемого значения, что и у метода родителя<br>
- Модификатор доступа у переопределенного метода также не может отличаться от «оригинального<br>
###15. Можно ли переопределить статический метод?
Статический метод нельзя переопределить. По аналогии с переменными, можно сказать, что этот метод "один для класса и его наследников" - так же, как статическая переменная "одна для класса и всех его объектов".<br>
    Выбор вызываемого статического метода происходит при раннем связывании (на этапе компиляции, а не выполнения) и выполняться всегда будет родительский метод, хотя синтаксически переопределение статического метода - это вполне корректная языковая конструкция. В целом, к статическим полям и методам рекомендуется обращаться через имя класса, а не объект.<br>
    Может быть перегружен. Статические методы умеют осуществлять "сокрытие" метода из суперкласса. Сокрытие методов, грубо говоря, представляет из себя "перекрытие" методом текущего класса, метода родительского класса.<br>
###16. Что такое виртуальная функция и используются ли они в Java?
Виртуальная функция в Java – одна из таких концепций, которая помогает в полиморфизме во время выполнения.<br>
    Виртуальная функция - это функция (метод), которая может быть переопределена наследником.<br>
    Поведение виртуальной функции может быть переопределено наследующей функцией класса с тем же именем. Она в основном определяется в базовом классе и переопределяется в унаследованном классе. Ожидается, что виртуальная функция будет определена в производном классе. Мы можем вызвать виртуальную функцию, ссылаясь на объект производного класса, используя ссылку или указатель базового класса. Каждый нестатический метод по умолчанию является виртуальным методом.<br>
    В Java нет виртуального ключевого слова, такого как C ++, но мы можем определить его и использовать для таких понятий, как полиморфизм во время выполнения.<br>
    В Java практически все функции виртуальные (private функции не могут быть переопределены в связи с правами видимости и final)<br>
    Функция не считается виртуальной функцией, потому что статический метод связан с самим классом. Поэтому мы не можем вызвать статический метод из имени объекта или класса для полиморфизма.<br>
    Полиморфизм во время выполнения – это когда вызов переопределенного метода разрешается во время выполнения, а не во время компиляции. Переопределенный метод вызывается через ссылочную переменную базового класса.<br>

class Edureka{<br>
public void show(){<br>
System.out.println("welcome to edureka");<br>
}<br>
}<br>
class Course extends Edureka{<br>
public void show(){<br>
System.out.println("Java Certification Program");<br>
}<br>
public static void main(String args[]){<br>
Edureka ob1 = new Course();<br>
ob1.show();<br>
}<br>
}<br>
Output: Java Certification Course<br>
Для виртуальной функции в Java вам не нужно явное объявление. Это любая функция, которая у нас есть в базовом классе и переопределена в производном классе с тем же именем.
###17. Что такое перегрузка метода?
Перегрузка метода - это наличие в классе нескольких методов с одним именем, но разными наборами параметров.<br>
    Перегрузить можно не только метод, но и конструктор.<br>
    При вызове перегруженного метода компилятор автоматически определяет нужный вариант метода по его параметрам, которые указываются при вызове.<br>
###18. Можно ли изменить тип возвращаемых данных при перегрузке метода?
Можно, если списки аргументов отличаются, иначе JVM не поймет какой метод ей нужно вызвать.<br>
    Т.е. если меняем тип возвращаемого значения, то мы также должны изменить список аргументов перегружаемого метода.
###19. Что такое множественное наследование? Как его можно реализовать в Java.
Множественное наследование – способность создавать классы с множеством классов-родителей (супер-классов) одновременно.<br>
    В Java запрещено множественное наследование главным образом из-за ромбовидной (алмазной) проблемы.<br>

компилятор не знает о том, метод какого именно суперкласса должен быть вызван. Благодаря очертаниям диаграммы наследования классов в этой ситуации, напоминающим очертания граненого алмаза проблема получила название «проблема Алмаза». Это и есть основная причина, почему в Java нет поддержки множественного наследования классов. Отметим, что указанная проблема с множественным наследованием классов также может возникнуть с тремя классами, имеющими как минимум один общий метод. В Java множественное наследование поддерживают интерфейсы.<br>
Если есть необходимость использовать методы из двух разных классов, то можно воспользоваться композицией. Для этого в третьем классе нужно создать два необходимых объекта, добавить методы, которые обращаются к нужным методам этих объектов. И наследоваться от этого класса.<br>
Если объекты связаны по типу «является», например ноутбук является компьютером. Если объекты связаны по типу «содержит», например ноутбук содержит hdd и cdrom, то композицию.<br>
###20. Что такое полиморфизм? Приведите примеры из реальной жизни.
Полиморфизм значит "много форм". Например, актер в театре может примерять на себя много ролей - или принимать "много форм".

Так же и наш код - благодаря полиморфизму он становится более гибким, чем в языках программирования, которые не используют принципы ООП.<br>
Как проявляется полиморфизм<br>
Если бы в Java не было принципа полиморфизма, компилятор бы интерпретировал это как ошибку:

Как видите, методы на картинке отличаются значениями, которые они принимают:
	первый принимает int
	а второй принимает String
Однако, поскольку в Java используется принцип полиморфизма, компилятор не будет воспринимать это как ошибку, потому что такие методы будут считаться разными:

Называть методы одинаково очень удобно. Например, если у нас есть метод, который ищет корень квадратный из числа, гораздо легче запомнить одно название (например, sqrt()), чем по одному отдельному названию на этот же метод, написанный для каждого типа:

Как видите, мы не должны придумывать отдельное название для каждого метода - а главное их запоминать! Очень удобно.<br>
поэтому часто этот принцип описывают фразой: Один интерфейс - много методов<br>
Это предполагает, что мы можем заполнить одно название (один интерфейс), по которому мы сможем обращаться к нескольким методам.<br>
Полиморфизм - это возможность работать с несколькими типами, как будьто это один и тот же тип, в то же время поведение каждого типа будет уникальным в зависимости от его реализации.<br>
Примеры:
•	Пульт управления один для разных моделей.
•	Монетоприемник в каком-нибудь продающем автомате.
•	Цоколь лампочки - это переменная определенного базового типа. Лампочка - созданный объект конкретного класса. Лампочки разные - цоколь один.
###21. Что такое инкапсуляция?
Инкапсуляция - это сокрытие реализации и отделение его внутреннего представления от внешнего.<br>
    Т.е. это скрытие полей объектов, ограничение доступа к определенным методам и полям.
###22. Как реализована инкапсуляция в Java?
специальные методы - геттеров и сеттеров.<br>
    модификаторы доступа - специальные слова, которые определяют доступ к данным.<br>
    Например, модификатором доступа private скрываются поля объекта, и при необходимости к ним разрешается подкотрольный доступ через геттеры и сеттеры.
###23. Можно ли применить модификаторы доступа к конструкторам?
В конструкторе допускается применение модификаторов доступа, можно задать один из модификаторов: public, protected, private или без модификатора.<br>
    Конструктор не может иметь модификаторов abstract, final, native, static или synchronized;
###24. Что такое интерфейс?
Интерфейс позволяет создавать общий тип данных для разных объектов, т.е. использование интерфейса гарантирует наличие определенного метода у объекта.<br>
    Класс — это, чаще всего модель какого-то конкретного объекта. Интерфейс же больше соответствует не объектам, а их способностям или ролям.<br>
    Например, такие вещи, как машина, велосипед, мотоцикл и колесо лучше всего представить в виде классов и объектов. А такие их способности, как «могу ездить», «могу перевозить людей», «могу стоять», лучше представить в виде интерфейсов.<br>
    Чтобы класс применил интерфейс, надо использовать ключевое слово implements<br>
    interface Printable{<br>

void print();<br>
    }<br>
    class Book implements Printable{

String name;<br>
    String author;<br>

Book(String name, String author){

this.name = name;<br>
        this.author = author;<br>
    }

1. Объявление интерфейса

- Вместо слова class пишем interface.<br>
- Содержит только абстрактные методы (слово abstract писать не нужно)<br>
- На самом деле у интерфейсов все методы – public<br>

2. Наследование интерфейсов

Интерфейс может наследоваться только от интерфейсов. Зато родителей у интерфейса может быть много. Еще говорят, что в Java есть множественное наследование интерфейсов.<br>
И самое важное: в интерфейсах нельзя объявлять переменные (хотя статические можно).<br>
Интерфейсы задают описание, как должен работать объект. Интерфейсы не содержат реализации. Это тип данных, который может содержать лишь константы (статические поля), абстрактные методы, а также начиная с Java 8 неабстрактные методы default и static.<br>
Также с Java 8 появилась возможность реализовывать методы с дефолтной реализацией, но опять же без конкретного состояния.<br>
При реализации интерфейса класс реализовать все его методы, иначе он должен быть помечен как abstract.<br>
Если у интерфейса только один абстрактный метод, перед нами функциональный интерфейс.<br>
###25. Какие типы исключительных ситуаций бывают?
Исключение — это проблема (ошибка) возникающая во время выполнения программы. Исключения могут возникать во многих случаях, например:<br>
- Пользователь ввел некорректные данные.<br>
- Файл, к которому обращается программа, не найден.<br>
- Сетевое соединение с сервером было утеряно во время передачи данных. И т.д.<br>
- Все исключения в Java являются объектами. Поэтому они могут порождаться не только автоматически при возникновении исключительной ситуации, но и создаваться самим разработчиком.

Исключения делятся на несколько классов, но все они имеют общего предка — класс Throwable. Его потомками являются подклассы Exception и Error.<br>
Throwable - суперкласс исключений. в нем вся логика. Остальные подклассы нужны для того, чтобы определить тип исключений:<br>
•	Error (unchecked) - неустранимые (как правило) на уровне JVM проблемы. Согласно спецификации Java, не следует пытаться обрабатывать их в собственной программе.  <br>
OutOfMemoryError - ошибка переполнения памяти JVM. Программа дополнительную память всё равно не сможет обеспечить для JVM. ThreadDeath - вызывается при неожиданной остановке потока посредством метода Thread.stop().<br>
StackOverflowError - ошибка переполнение стека. Часто возникает в рекурсивных функциях из-за неправильного условия выхода.<br>
•	Exception (checked) - являются результатом проблем в программе, которые в принципе решаемые и предсказуемые. Они обязательны для обработки и обычно связаны с бизнес-логикой приложения.<br>
-	IOException (checked) ошибки созданные неудачными или прерванными операциями ввода-вывода.  <br>
-	SQLException (checked) ошибки доступа к базе данных или другие ошибки, связанных с работой с базами данных.<br>
-	RuntimeException (unchecked) - результат некорректного программирования, компилятор не требует их обработки.  <br>
IndexOutOfBoundsException - выбрасывается, когда индекс некоторого элемента в структуре данных (массив/коллекция) не попадает в диапазон имеющихся индексов.<br>
NullPointerException - ссылка на объект, к которому вы обращаетесь хранит null.<br>
ClassCastException – Ошибка приведения типов. Всякий раз при приведении типов делается проверка на возможность приведения (проверка осуществляется с помощью instanceof).<br>
ArithmeticException - бросается когда выполняются недопустимые арифметические операции, например деление на ноль.<br>
Проверяемые исключения (checked) - это те исключения, которые проверяются при компиляции. Если вы не обработаете их, вы получите ошибку компиляции.<br>
Непроверяемые исключения (unchecked) - это те исключения, которые не проверяются во время компиляции. JVM не будет «ругаться», если вы не обработаете такие исключения.<br>
###26. Назовите основные методы класса Object?
*	public native int hashCode() — возвращает хеш-код объекта.
*	public boolean equals(Object obj) — сравнивает объекты.
*	public String toString() — возвращает строковое представление объекта.
*	public final native Class getClass() — возвращает в рантайме класс данного объекта.
*	protected native Object clone() throws CloneNotSupportedException — клонирование объекта
*	public final native void notify() — просыпается один поток, который ждет на "мониторе" данного объекта.
*	public final native void notifyAll() — просыпаются все потоки, которые ждут на "мониторе" данного объекта.
*	public final native void wait(long timeout) throws InterruptedException — поток переходит в режим ожидания в течение указанного времени.
*	public final void wait() throws InterruptedException — приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() методы для этого объекта.
*	public final void wait(long timeout, int nanos) throws InterruptedException — приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() для этого метода, или пока не истечет указанный промежуток времени.
*	protected void finalize() throws Throwable — вызывается сборщиком мусора, когда garbage collector определил, что ссылок на объект больше нет.
Модификатор native сигнализирует о том, что метод реализован в платформо-зависимом коде, часто на языке С.
###27. Что такое шаблоны проектирования?
Паттерн переводится с английского как "шаблон". То есть это некоторый образец, по которому мы что-то делаем. Так и в программировании. Есть некоторые выработанные лучшие практики (best practice) и подходы к решению часто встречаемых проблем.<br>
    Каждый программист — архитектор. Даже когда Вы создаёте всего несколько классов или даже один — от Вас зависит, на сколько код сможет выживать под изменением требований, на сколько он удобен в использовании другими. И вот тут как раз и поможет знание шаблонов, т.к. это позволит быстрее понять, как лучше написать код так, чтобы не переписывать его. Как известно, программисты — люди ленивые и проще написать сразу хорошо, чем переделывать несколько раз)<br>
    Ещё паттерны могут показаться похожим на алгоритмы. Но у них есть разница. Алгоритм состоит из конкретных шагов, описывающих необходимые действия. Паттерны же лишь описывают подход, но не описывают шаги реализации.<br>
    Паттерны бывают разные, т.к. решают разные проблемы. Обычно выделяют следующие категории:<br>
- Порождающие<br>
  Эти паттерны решают проблемы обеспечения гибкости создания объектов<br>
- Структурные<br>
  Эти паттерны решают проблемы эффективного построения связей между объектами<br>
- Поведенческие<br>
  Эти паттерны решают проблемы эффективного взаимодействия между объектами
###28. Объясните шаблон - декоратор.
Декоратор — это структурный паттерн, который позволяет добавлять объектам новые поведения на лету, помещая их в объекты-обёртки.<br>
    Декоратор позволяет оборачивать объекты бесчисленное количество раз благодаря тому, что и обёртки, и реальные оборачиваемые объекты имеют общий интерфейс.<br>
    Смысл Декоратора - добавление нового поведения в уже существующее поведение.<br>

Base интерфейс описывающий поведение.<br>
Class класс реализующий поведение.<br>
Decor класс реализующий поведение и зависимый от другой реализации Base.<br>
Этот шаблон проектирования предназначен для динамического подключения дополнительного поведения к объекту. «Декоратор» обычно выступает как альтернатива набору классов-наследников с этим дополнительным поведением.<br>
У шаблона говорящее название: он берёт какой-то объект и добавляет к нему декорации-рюшечки. Но какие бы украшения мы ни применили, в итоге должен получиться объект того же типа — просто с дополнительными возможностями. После декорирования супергероя суперспособностями должен получиться супергерой с суперспособностями, а не трансформер или динозавр, например.<br>
*	Класс-декоратор должен быть того же типа, что и декорируемый класс, — реализовывать тот же интерфейс или наследовать тот же базовый класс.
*	Декоратор реализует поведение исходного класса; при этом не изменяет его, а добавляет своё до или после вызова базового поведения.
*	Это достигается за счёт того, что декоратор содержит в себе объект базового класса и вызывает его методы там, где требуется дополнить поведение.
Вот как это выглядит на диаграмме классов:

Здесь всего два типа классов: «обычные» — ConcreteComponent — и классы-декораторы, которые наделяют их новыми возможностями. Такие классы ещё называют классами-обёртками, потому что внутри каждой обёртки лежит объект.<br>
Представляйте это как многослойную одежду: первый слой отводит влагу, второй — сохраняет тепло, третий — защищает от ветра и дождя. Всё вместе «оборачивает» человека и наделяет суперспособностью — выдерживать капризы погоды<br>
Шаблон «Декоратор» полезен, когда нужно динамически предоставлять объектам дополнительные возможности. Это хорошая альтернатива наследованию в том случае, когда в логике программы не нужно учитывать конкретные типы декорируемых объектов.<br>
###29. Объясните шаблон - стратегия.
Стратегия — это поведенческий паттерн, выносит набор алгоритмов в собственные классы и делает их взаимозаменимыми.<br>
    Другие объекты содержат ссылку на объект-стратегию и делегируют ей работу. Программа может подменить этот объект другим, если требуется иной способ решения задачи. относится к поведенческим (behavioral) паттернам проектирования. Также известен как Политика (Policy).<br>
    Примеры: оплата в интернет магазине (карта, paypal, яндекс.деньги) / заправка для бензиновых, дизельных, электромобилей и т.д<br>

extends это ключевое слово, предназначенное для расширения реализации какого-то существующего класса. Создается новый класс на основе существующего, и этот новый класс расширяет (extends) возможности старого.<br>
implements это ключевое слово, предназначенное для реализации интерфейса (interface).<br>

В Java существует ключевое слово super, которое обозначает суперкласс, т.е. класс, производным от которого является текущий класс. В данном случае, супер не означает превосходство, скорее даже наоборот, дочерний класс имеет больше методов, чем родительский.<br>

Ключевое слово super можно использовать для вызова конструктора суперкласса и для обращения к члену суперкласса, скрытому членом подкласса.<br>
Использование ключевого слова super для вызова конструктора суперкласса<br>
Перепишем пример:<br>

class HeavyBox extends Box {<br>
int weight; // вес коробки<br>

//    конструктор<br>
    // инициализируем переменные с помощью ключевого слова super<br>
    HeavyBox(int w, int h, int d, int m) {<br>
        super(w, h, d); // вызов конструктора суперкласса<br>
        weight = m; // масса<br>
    }<br>
}<br>
Вызов метода super() всегда должен быть первым оператором, выполняемым внутри конструктора подкласса.<br>